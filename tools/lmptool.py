#!/usr/bin/env python3
# coding=utf-8
"""
TensorAlloy - STEPMAX - Lammps Utility Tools
"""
from __future__ import print_function, absolute_import

import tensorflow as tf
import numpy as np
import pandas as pd
import toml
import re
import sys

from dataclasses import dataclass
from argparse import ArgumentParser, Namespace
from ase.calculators.lammpsrun import write_lammps_data, LAMMPS, Prism
from ase.io import write, read
from ase.units import Hartree
from ase.geometry import cell_to_cellpar
from ase import Atoms
from os.path import dirname, exists, join
from typing import List
from dscribe.descriptors import SOAP
from dscribe.kernels import REMatchKernel
from enum import Enum

from tensoralloy.io.xyz import read_stepmax_xyz, write_stepmax_xyz
from tensoralloy.cli.entry import CLIProgram
from tensoralloy.transformer import SymmetryFunctionTransformer
from tensoralloy.analysis.elastic import get_lattice_type
from tensoralloy.utils import set_pulay_stress

__author__ = 'Xin Chen'
__email__ = 'Bismarrck@me.com'


class SimilarityAlgorithm(Enum):
    """
    The algorithm for computing the similarity of any two structures.
    """
    sf = 0
    soap = 1


@dataclass(frozen=True)
class SpaceGroup:
    lattice: str
    name: str
    number: int


@dataclass(frozen=True)
class BestRow:
    order: int
    enthalpy: float
    dH: float
    seq: int
    energy: float
    descriptors: np.ndarray
    spacegroup: SpaceGroup
    atoms: Atoms


@dataclass(frozen=True)
class BestFile:
    rows: List[BestRow]

    def __getitem__(self, item: int) -> BestRow:
        return self.__dict__['rows'][item]

    def __len__(self):
        return len(self.__dict__['rows'])


def read_best_file(best_file: str,
                   pulay_stress=0.0,
                   vasp=True,
                   algo=SimilarityAlgorithm.soap) -> BestFile:
    """
    Read the `best.txt` generated by STEPMAX.
    """
    best_dir = dirname(best_file)
    jobs_dir = join(best_dir, '..', 'jobs')
    elements = None

    with open(best_file) as fp:
        rows = []
        best_patt = re.compile(r"\s+(\d+)\s+([0-9-.]+)\s+([\d.]+)\s+(\d+)")
        for line in fp:
            m = best_patt.search(line)
            if m:
                order = int(m.group(1))
                H = float(m.group(2)) * Hartree
                dH = float(m.group(3))
                seq = int(m.group(4))
                if vasp:
                    poscar = join(best_dir, f"best{order}.POSCAR")
                    atoms = read(poscar, format='vasp')
                else:
                    xyzfile = join(best_dir, f"best{order}.xyz")
                    atoms = read_stepmax_xyz(xyzfile)
                atoms.wrap()

                if elements is None:
                    elements = sorted(list(set(atoms.get_chemical_symbols())))

                set_pulay_stress(atoms, pulay_stress)
                E = H - pulay_stress * atoms.get_volume()

                if algo == SimilarityAlgorithm.soap:
                    npzfile = join(jobs_dir, str(seq), "opt", "g_soap.npz")
                    ar = np.load(npzfile)
                    g = ar["soap"]
                else:
                    raise ValueError(
                        f"Similarity algorithm {algo.name} is not implemented!")

                latfile = join(jobs_dir, str(seq), "opt", "lattice.toml")
                with open(latfile) as fp:
                    adict = toml.load(fp)
                sg = SpaceGroup(adict['lattice_name'], adict['sg_name'],
                                adict['sg_number'])
                row = BestRow(order=order, enthalpy=H, dH=dH, seq=seq, energy=E,
                              descriptors=g, spacegroup=sg, atoms=atoms)
                rows.append(row)
        return BestFile(rows)


class AdvancedSummaryProgram(CLIProgram):
    """
    Generate an advanced summary report of a `best` dir.
    """

    @property
    def name(self):
        return "summarize"

    @property
    def help(self):
        return "Summerize a `best` dir."

    @property
    def main_func(self):
        """
        The main function.
        """

        def func(args: Namespace):
            best = read_best_file(args.best_file, args.pulay_stress,
                                  vasp=args.vasp, algo=SimilarityAlgorithm.soap)
            best_dir = dirname(args.best_file)
            max_size = len(best)
            size = 0
            max_dH = max(0, args.max_dH)
            enthalpy = np.zeros(max_size)
            x = []
            for i in range(max_size):
                enthalpy[i] = best[i].enthalpy
                x.append(best[i].descriptors)
                if best[i].dH > max_dH:
                    break
                size += 1
            x = np.array(x)
            enthalpy = np.resize(enthalpy, (size,))
            duplicated = np.zeros(size, dtype=bool)
            kernel = REMatchKernel(metric='rbf', alpha=1.0, gamma=1.0)
            for i in range(size):
                if duplicated[i]:
                    continue
                row = best[i]
                dH = enthalpy - row.enthalpy
                idx = np.argwhere(
                    np.logical_and(dH < args.lookup_dH, dH >= 0.0)).flatten()
                if len(idx) == 1 and idx[0] == i:
                    continue
                C = kernel.create(x[idx], [row.descriptors]).flatten()
                for c_idx in range(len(C)):
                    if idx[c_idx] == i:
                        continue
                    if C[c_idx] > args.sim_thres:
                        duplicated[idx[c_idx]] = True
                if args.verbose and (i + 1) % 10 == 0:
                    sys.stdout.write(
                        "\rSim Check: {:5d} / {:5d}".format(i + 1, size))
            if args.verbose:
                print(f"\n{size - duplicated.sum()} unique structures found.")
            data = {'Order': [], 'JobId': [], 'H': [], 'E': [], 'Lattice': [],
                    'SpaceGroup': [], 'A': [], 'B': [], 'C': [], 'Alpha': [],
                    'Beta': [], 'Gamma': []}
            for i in range(size):
                if duplicated[i]:
                    continue
                row = best[i]
                pars = cell_to_cellpar(row.atoms.cell.array)
                data['Order'].append(row.order)
                data['JobId'].append(row.seq)
                data['H'].append(row.enthalpy)
                data['E'].append(row.energy)
                data['Lattice'].append(row.spacegroup.lattice)
                data['SpaceGroup'].append(row.spacegroup.name)
                data['A'].append("%.3f" % pars[0])
                data['B'].append("%.3f" % pars[1])
                data['C'].append("%.3f" % pars[2])
                data['Alpha'].append("%.2f" % pars[3])
                data['Beta'].append("%.2f" % pars[4])
                data['Gamma'].append("%.2f" % pars[5])

            if args.refnpz is not None:
                ref = np.load(args.refnpz)["soap"]
                idx = np.argwhere(duplicated == False).flatten()
                C = kernel.create(x[idx], [ref])
                data['Sim/Ref'] = C.flatten()

            df = pd.DataFrame(data)
            df.set_index('Order', inplace=True)
            csv_file = join(best_dir, "best.csv")
            df.to_csv(csv_file)
            with open(join(best_dir, "best.adv.txt"), 'w') as fp:
                fp.write(df.to_string())
            print(df.to_string())

        return func

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the parser.
        """
        subparser.add_argument(
            'best_file',
            type=str,
            help="The target 'best.txt' generated by STEPMAX."
        )
        subparser.add_argument(
            "--pulay-stress",
            type=float,
            default=0.0,
            help="The pulay stress (GPa)."
        )
        subparser.add_argument(
            "--vasp",
            action="store_true",
            default=False,
            help="Set the default STEPMAX file type to VASP/POSCAR."
        )
        subparser.add_argument(
            "--max-dH",
            type=float,
            default=4.0,
            help="Set the max allowed dH (eV)."
        )
        subparser.add_argument(
            "--lookup-dH",
            type=float,
            default=1.0,
            help="Set the range (eV) of the lookup window for checking "
                 "duplicates."
        )
        subparser.add_argument(
            "--sim-thres",
            type=float,
            default=0.95,
            help="The threshold for checking duplicates."
        )
        subparser.add_argument(
            "--refnpz",
            type=str,
            default=None,
            help="A npz file for reading SOAP features of the reference."
        )
        subparser.add_argument(
            "-v", "--verbose",
            default=False,
            action="store_true",
        )
        super(AdvancedSummaryProgram, self).config_subparser(subparser)


class XyzToLmpDataProgram(CLIProgram):
    """
    Dump a `JobId_opt.xyz` to its corresponding Lammps data file.
    """

    @property
    def name(self):
        return "xyz2lmp"

    @property
    def help(self):
        return "Dump a `JobId_opt.xyz` to its corresponding Lammps data file."

    @property
    def main_func(self):
        """
        The main function for this program.
        """

        def func(args: Namespace):
            atoms = read_stepmax_xyz(args.xyzfile)
            atoms.wrap()
            if args.output is None:
                output = "data.lammps"
            else:
                output = args.output
            with open(output, 'wb') as fileobj:
                write_lammps_data(fileobj, atoms)

        return func

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the parser.
        """
        subparser.add_argument(
            'xyzfile',
            type=str,
            help="The target stepmax/xyz file."
        )
        subparser.add_argument(
            "--output",
            type=str,
            default=None,
            help="The output Lammps data file."
        )
        super(XyzToLmpDataProgram, self).config_subparser(subparser)


class LmpTrajectoryProgram(CLIProgram):
    """
    Parse Lammps trajectory & log files and write the final step to a
    stepmax/xyz file.
    """

    @property
    def name(self):
        return "trajectory"

    @property
    def help(self):
        return "Parse Lammps trajectory & log files and write the final step " \
               "to a stepmax/xyz file."

    @property
    def main_func(self):
        """
        The main function.
        """

        def func(args: Namespace):
            tmp_dir = dirname(args.trajectory)
            lmp = LAMMPS(tmp_dir)

            ref = read_stepmax_xyz(args.refxyz)
            lmp.atoms = ref
            lmp.prism = Prism(ref.cell.array.copy())

            logfile = args.logfile
            if logfile is None:
                for possible_name in ("log.lammps", "lammps.out"):
                    afile = join(tmp_dir, possible_name)
                    if exists(afile):
                        logfile = afile
                        break
            if not logfile:
                raise ValueError("The Lammps logfile cannot be accessed!")

            with open(logfile, 'rb') as fp:
                lmp.read_lammps_log(fp)
            lmp.read_lammps_trj(args.trajectory, set_atoms=True)

            atoms = lmp.atoms
            atoms.wrap()
            energy = lmp.thermo_content[-1]['etotal']

            fnorm = np.linalg.norm(lmp.forces)
            if fnorm <= np.sqrt(3.0 * len(atoms)) * 1e-2:
                write_stepmax_xyz(args.output, atoms, energy=energy)
                write(join(tmp_dir, "POSCAR"), atoms, format='vasp', vasp5=True,
                      direct=True)
            else:
                write_stepmax_xyz(f"{args.output}.err", lmp.atoms)

        return func

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the parser.
        """
        subparser.add_argument(
            "trajectory",
            type=str,
            help="The Lammps trajectory file."
        )
        subparser.add_argument(
            "refxyz",
            type=str,
            help="A stepmax/xyz file as the reference structure for "
                 "transforming Lammps coordinates."
        )
        subparser.add_argument(
            "--output",
            type=str,
            default="opted.xyz",
            help="The output stepmax/xyz file."
        )
        subparser.add_argument(
            "--logfile",
            default="log.lammps",
            type=str,
            help="The Lammps output."
        )
        super(LmpTrajectoryProgram, self).config_subparser(subparser)


class SymmetryFunctionDescriptorProgram(CLIProgram):
    """
    A program for computing symmetry function descriptors of an optimized
    structure.
    """

    @property
    def name(self):
        return "sf"

    @property
    def help(self):
        return "Compute symmetry function descriptors of a structure."

    @property
    def main_func(self):
        """
        The main function.
        """

        def func(args: Namespace):
            algo = SimilarityAlgorithm.sf.value
            if args.config is None:
                rc = 7.5
                eta = np.array([0.1, 0.5, 1.0, 2., 4., 8., 16., 20.])
                omega = np.array([0.0, 3.0])
                angular = True
                beta = np.array([0.01, 0.1, 0.5, 1.0, 2.0])
                gamma = np.array([1.0, -1.0])
                zeta = np.array([1.0, 4.0])
            else:
                with open(args.config) as fp:
                    cfg = toml.load(fp)
                    rc = cfg['rc']
                    eta = cfg['sf']['eta']
                    omega = cfg['sf']['omega']
                    angular = cfg['sf']['angular']
                    beta = cfg['sf']['beta']
                    gamma = cfg['sf']['gamma']
                    zeta = cfg['sf']['zeta']
            atoms = read(args.poscar, index=-1, format="vasp")
            elements = sorted(list(set(atoms.get_chemical_symbols())))
            clf = SymmetryFunctionTransformer(rc, elements, eta, omega, beta,
                                              gamma, zeta, angular)
            with tf.Graph().as_default():
                g = clf.get_descriptors(clf.get_constant_features(atoms))
                config = tf.ConfigProto(device_count={'CPU': 1})
                config.inter_op_parallelism_threads = 1
                config.intra_op_parallelism_threads = 1
                with tf.Session(config=config) as sess:
                    tf.global_variables_initializer().run()
                    values = sess.run(g)

            dump = {element: values[element][0] for element in elements}
            np.savez(args.npzfile, algo=algo, **dump)

        return func

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the parser.
        """
        subparser.add_argument(
            "poscar",
            type=str,
            help="A POSCAR to read"
        )
        subparser.add_argument(
            "--npzfile",
            type=str,
            default="g_sf.npz",
            help="The npzfile for storing symmetry function descriptors."
        )
        subparser.add_argument(
            "--config",
            type=str,
            default=None,
            help="A toml config file."
        )
        super(SymmetryFunctionDescriptorProgram,
              self).config_subparser(subparser)


class SoapProgram(CLIProgram):
    """
    A program to compute the SOAP fingerprints.
    """

    @property
    def name(self):
        return "soap"

    @property
    def help(self):
        return "Compute SOAP descriptors of a structure."

    @property
    def main_func(self):
        """
        The main function.
        """

        def func(args: Namespace):
            algo = SimilarityAlgorithm.soap.value
            if args.config is None:
                rc = 7.5
                nmax = 10
                lmax = 5
                crossover = True
            else:
                with open(args.config) as fp:
                    cfg = toml.load(fp)
                    rc = cfg['rc']
                    nmax = cfg['soap']['nmax']
                    lmax = cfg['soap']['lmax']
                    crossover = cfg['soap']['crossover']
            atoms = read(args.poscar, index=-1, format="vasp")
            periodic = any(atoms.pbc)
            species = sorted(list(set(atoms.get_chemical_symbols())))
            soap = SOAP(species=species, rcut=rc, nmax=nmax, lmax=lmax,
                        periodic=periodic, average=False, crossover=crossover)
            np.savez(args.npzfile, algo=algo, soap=soap.create(atoms))

        return func

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the parser.
        """
        subparser.add_argument(
            "poscar",
            type=str,
            help="A POSCAR to read"
        )
        subparser.add_argument(
            "--npzfile",
            type=str,
            default="g_soap.npz",
            help="The npzfile for storing symmetry function descriptors."
        )
        subparser.add_argument(
            "--config",
            type=str,
            default=None,
            help="A toml config file."
        )
        super(SoapProgram, self).config_subparser(subparser)


class SpacegroupProgram(CLIProgram):
    """
    A program to analyze spacegroup of a structure.
    """

    @property
    def name(self):
        return "spacegroup"

    @property
    def help(self):
        return "Analyze the spacegroup of the target structure."

    @property
    def main_func(self):
        def func(args: Namespace):
            atoms = read(args.poscar, index=-1, format='vasp')
            lattice_name, sg_name, sg_nr = get_lattice_type(
                atoms, symprec=args.symprec)[1:]
            with open(args.output, 'w') as fp:
                toml.dump(
                    {'lattice_name': lattice_name,
                     'sg_name': sg_name,
                     'sg_number': sg_nr,
                     'precision': args.symprec}, fp)

        return func

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the parser.
        """
        subparser.add_argument(
            "poscar",
            type=str,
            help="A POSCAR to read"
        )
        subparser.add_argument(
            "--output",
            type=str,
            default="lattice.toml",
            help="The output toml for writting lattice details."
        )
        subparser.add_argument(
            "--symprec",
            type=float,
            default=0.01,
            help="The precision for finding spacegroup of a structure."
        )
        super(SpacegroupProgram, self).config_subparser(subparser)


class ComputeProgram(CLIProgram):
    """
    A collection of programs for computing advanced evaluation metrics.
    """

    def __init__(self):
        """
        Initiazliation method.
        """
        super(ComputeProgram, self).__init__()

        self._programs = [
            SymmetryFunctionDescriptorProgram(),
            SoapProgram(),
            SpacegroupProgram(),
        ]

    @property
    def name(self):
        """
        The name of this CLI program.
        """
        return "compute"

    @property
    def help(self):
        """
        The help message
        """
        return "Compute advanced metrics."

    def config_subparser(self, subparser: ArgumentParser):
        """
        Config the subparaser.
        """
        subsubparsers = subparser.add_subparsers(title=self.name,
                                                 help=self.help)
        for prog in self._programs:
            subsubparser = subsubparsers.add_parser(prog.name, help=prog.help)
            prog.config_subparser(subsubparser)
        super(ComputeProgram, self).config_subparser(subparser)

    @property
    def main_func(self):
        """ The main function. This is just a program-collection, so this
        function is empty. """

        def func(_):
            pass

        return func


def cli():
    """
    The entry function of this CLI program.
    """
    parser = ArgumentParser()

    subparsers = parser.add_subparsers(
        title="Commands",
        metavar='TensorAlloy-Lammps-STEPMAX tools.'
    )

    for prog in (XyzToLmpDataProgram(),
                 LmpTrajectoryProgram(),
                 ComputeProgram(),
                 AdvancedSummaryProgram()):
        subparser = subparsers.add_parser(prog.name, help=prog.help)
        prog.config_subparser(subparser)

    args = parser.parse_args()
    if 'func' not in args:
        parser.print_help()
    else:
        args.func(args)


if __name__ == "__main__":
    cli()
