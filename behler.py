# coding=utf-8
"""
The implementations of Behler's Symmetry Functions.
"""
from __future__ import print_function, absolute_import

import tensorflow as tf
from ase import Atoms
from ase.neighborlist import neighbor_list
from utilities import cutoff, pairwise_dist

__author__ = 'Xin Chen'
__email__ = 'Bismarrck@me.com'


def build_radial_v2g_map(atoms: Atoms, rc: float, n_etas: int):
    """

    Parameters
    ----------
    atoms : Atoms
        An `ase.Atoms` object representing a structure.
    rc : float
        The cutoff radius.
    n_etas : int
        The number of `eta` for radial symmetry functions.

    Returns
    -------
    v2g_map : Sized
        A list of (i, l) pairs where i is the index of the center atom and k is
        the index of the corresponding `eta`.
    pairs : dict
        A dict with three key-value pairs:

        'ii' : list
            A list of first atom indices.
        'jj' : list
            A list of second atom indices.
        'ij' : list
            A list of (i, j) pairs where i is the index of the center atom and j
            is the index of its neighbor atom.

    """
    ii, jj = neighbor_list('ij', atoms, rc)
    ij = list(zip(ii, jj))
    v2g_map = []
    for k in range(n_etas):
        v2g_map.append([(ii[idx], k) for idx in range(len(ii))])
    return v2g_map, {'ii': ii, 'jj': jj, 'ij': ij}


def build_angular_v2g_map(pairs, ndim):
    """

    Parameters
    ----------
    pairs : dict
        A dict with three key-value pairs generated by `build_radial_v2g_map`.
        This dict describe indices of pairwise interactions.
    ndim : int
        The total number of angular parameter sets.

    Returns
    -------
    v2g_map : Sized
        A list of (i, l) pairs where i is the index of the center atom and k is
        the index of the corresponding `eta`.
    triples : dict
        A dict with four key-value pairs.

    """
    triples = {'ij': [], 'ik': [], 'jk': [], 'ii': []}
    nl = {}
    for idx, atomi in enumerate(pairs['ii']):
        nl[atomi] = nl.get(atomi, []) + [pairs['jj'][idx]]
    n = 0
    for atomi, jlist in nl.items():
        for atomj in jlist:
            for atomk in jlist:
                if atomj == atomk:
                    continue
                triples['ij'].append((atomi, atomj))
                triples['ik'].append((atomi, atomk))
                triples['jk'].append((atomj, atomk))
                triples['ii'].append(atomi)
                n += 1
    v2g_map = []
    for k in range(ndim):
        v2g_map.append([(triples['ii'][idx], k) for idx in range(n)])
    return v2g_map, triples


def radial_function(R: tf.Tensor, rc: float, eta_list: list, ij: list,
                    v_to_g_map: list):
    """
    The implementation of Behler's radial symmetry function for a single
    structure.
    """
    ndim = len(eta_list)
    N = R.shape[0]
    r = pairwise_dist(R, R, name='pdist')
    rc2 = tf.constant(rc ** 2, dtype=tf.float64, name='rc2')
    eta = tf.constant(eta_list, dtype=tf.float64, name='eta')
    r = tf.gather_nd(r, ij, name='rd')
    r2 = tf.square(r, name='rd2')
    fc_r = cutoff(r, rc, name='cutoff')
    g = tf.Variable(tf.zeros((N, ndim), dtype=tf.float64), trainable=False)
    v = tf.negative(tf.tensordot(eta, tf.div(r2, rc2), axes=0))
    v = tf.exp(v, name='exp')
    v = tf.multiply(v, fc_r, name='damped')
    ops = []
    for row in range(ndim):
        ops.append(tf.scatter_nd_add(g, v_to_g_map[row], v[row]))
    with tf.control_dependencies(ops):
        return tf.identity(g)


def angular_function(R: tf.Tensor, rc: float, indices: dict, eta_list: list,
                     gamma_list: list, zeta_list: list, v_to_g_map: list):
    """
    The implementation of Behler's angular symmetry function for a single
    structure.
    """
    one = tf.constant(1.0, dtype=tf.float64)
    half = tf.constant(0.5, dtype=tf.float64)
    two = tf.constant(2.0, dtype=tf.float64)
    ndim = len(eta_list) * len(gamma_list) * len(zeta_list)
    N = R.shape[0]

    r = pairwise_dist(R, R, name='pdist')
    r2 = tf.square(r)
    rc2 = tf.constant(rc ** 2, dtype=tf.float64, name='rc2')

    r_ij = tf.gather_nd(r, indices['ij'], name='ij3')
    r_ik = tf.gather_nd(r, indices['ik'], name='ik3')
    r_jk = tf.gather_nd(r, indices['jk'], name='jk3')

    # Compute $\cos{(\theta_{ijk})}$ using the cosine formula
    b2c2a2 = tf.square(r_ij) + tf.square(r_ik) - tf.square(r_jk)
    bc = tf.multiply(r_ij, r_ik, name='bc')
    bc = tf.multiply(two, bc, name='2bc')
    cos_theta = tf.div(b2c2a2, bc, name='cos_theta')

    # Compute the damping term: $f_c(r_{ij}) * f_c(r_{ik}) * f_c(r_{jk})$
    fc_r_ij = cutoff(r_ij, rc, name='fc_r_ij')
    fc_r_ik = cutoff(r_ik, rc, name='fc_r_ik')
    fc_r_jk = cutoff(r_jk, rc, name='fc_r_jk')
    fc_r_ijk = fc_r_ij * fc_r_ik * fc_r_jk

    # Compute $R_{ij}^{2} + R_{ik}^{2} + R_{jk}^{2}$
    r2_ij = tf.gather_nd(r2, indices['ij'], name='r2_ij')
    r2_ik = tf.gather_nd(r2, indices['ik'], name='r2_ik')
    r2_jk = tf.gather_nd(r2, indices['jk'], name='r2_jk')
    r2_sum = r2_ij + r2_ik + r2_jk

    g = tf.Variable(tf.zeros((N, ndim), dtype=tf.float64), trainable=False)
    group = []
    row = 0
    for eta in eta_list:
        for gamma in gamma_list:
            for zeta in zeta_list:
                gamma_ = tf.constant(gamma, dtype=tf.float64)
                eta_ = tf.constant(eta, dtype=tf.float64)
                zeta_ = tf.constant(zeta, dtype=tf.float64)
                v = one + tf.multiply(gamma_, cos_theta)
                v = tf.pow(v, zeta_, name='pow')
                v = tf.pow(two, one - zeta_) * v
                v = v * tf.exp(-eta_ * r2_sum / rc2) * fc_r_ijk
                group.append(tf.scatter_nd_add(g, v_to_g_map[row], v))
                row += 1
    with tf.control_dependencies(group):
        return tf.multiply(half, g)
